import numpy as np
import random

def fitness_func(solution, returns, risks, max_risk):
    # Calculates fitness of solution
    returns_sum = np.sum(solution * returns)
    risks_sum = np.sqrt(np.dot(solution, np.dot(risks, solution)))
    if risks_sum > max_risk:
        return 0.0
    else:
        return returns_sum / np.sqrt(risks_sum)

def beetle_swarm_optimisation(num_iterations, num_beetles, num_assets, returns, risks, max_risk, c1, c2, c3, w, d0):
    # Initialize beetles
    beetles = np.random.rand(num_beetles, num_assets)
    for i in range(num_beetles):
        beetles[i] /= np.sum(beetles[i])

    # Initialize velocities
    velocities = np.random.rand(num_beetles, num_assets)

    # Initialize the best solution and fitness
    p_best = beetles.copy()
    p_fitness = np.array([fitness_func(solution, returns, risks, max_risk) for solution in p_best])
    g_best = p_best[np.argmax(p_fitness)].copy()
    g_fitness = np.max(p_fitness)

    # Main loop
    for iteration in range(num_iterations):
        for i in range(num_beetles):
            # Randomise beetle direction
            direction = np.random.rand(num_assets)

            # Calculate left and right positions and fitness
            x_left = beetles[i] + d0 * direction / 2
            x_right = beetles[i] - d0 * direction / 2
            f_left = fitness_func(x_left, returns, risks, max_risk)
            f_right = fitness_func(x_right, returns, risks, max_risk)

            # Calculate speed update rule generated by left and right fitness
            v_beetle = w * d0 * random.uniform(0, 1) * np.sign(f_right - f_left)

            # Calculate speed update rule generated by individual and global best
            v_particle = c1 * random.uniform(0, 1) * (p_best[i] - beetles[i]) + \
                         c2 * random.uniform(0, 1) * (g_best - beetles[i])

            # Combine speed update rules
            velocities[i] = w * velocities[i] + v_particle + c3 * random.uniform(0, 1) * v_beetle

            # Update position
            beetles[i] += velocities[i]
            beetles[i] /= np.sum(beetles[i])

            # Update individual best and global best
            curr_fitness = fitness_func(beetles[i], returns, risks, max_risk)

            if curr_fitness > p_fitness[i]:
                p_best[i] = beetles[i].copy()
                p_fitness[i] = curr_fitness
            if curr_fitness > g_fitness:
                g_best = beetles[i].copy()
                g_fitness = curr_fitness

        # Update learning factors and inertia weight
        c1 = 0.5 + 2 * iteration / num_iterations
        c2 = 2 - 2 * iteration / num_iterations
        c3 = 3 + 2 * iteration / num_iterations
        w = 0.9 - 0.5 * iteration / num_iterations

    return g_best, g_fitness


if __name__ == "__main__":
    num_iterations = 4000
    num_beetles = 40
    num_assets = 9

    returns = np.array([0.0190, 0.1900, 0.0358, 0.0343, 0.0466, 0.2288, 0.0188, 0.0422, 0.0679])
    cov_matrix = np.array([[10.8, 0.8, 3.9, 2.9, -4.2, 3.1, -1.0, 3.9, -0.5],
                           [0.8, 1.5, 0.9, -0.2, -2.6, 0.8, -1.3, 0.9, 0.4],
                           [3.9, 0.9, 2.2, 0.9, -2.2, 1.9, -1.1, 2.2, 0.1],
                           [2.9, -0.2, 0.9, 2.0, 0.2, 0.9, 0.0, 0.9, -0.2],
                           [-4.2, -2.6, -2.2, 0.2, 10.4, -0.8, -1.9, -2.2, -1.2],
                           [3.1, 0.8, 1.9, 0.9, -0.8, 2.0, -1.4, 1.9, 0.2],
                           [-1.0, -1.3, -1.1, 0.0, -1.9, -1.4, 13.2, -1.1, -0.1],
                           [3.9, 0.9, 2.2, 0.9, -2.2, 1.9, -1.1, 2.2, 0.1],
                           [-0.5, 0.4, 0.1, -0.2, -1.2, 0.2, -0.1, 0.1, 2.4]])
    max_risk = 0.1

    c1 = 0.5
    c2 = 2
    c3 = 3
    w = 0.9
    d0 = 2.0

    g_best_rez, g_fitness_rez = beetle_swarm_optimisation(
        num_iterations,
        num_beetles,
        num_assets,
        returns,
        cov_matrix,
        max_risk,
        c1,
        c2,
        c3,
        w,
        d0
    )

    print(g_best_rez)
    print(g_fitness_rez)
